from rest_framework import serializers
from django.core.validators import RegexValidator
from .models import User, TimeLog, AllowedIP, Committee, UserCommittee
from django.utils import timezone


class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'access_code', 'full_name', 'role', 'target_hours_per_week', 'created_at']
        read_only_fields = ['created_at']


class UserCreateSerializer(serializers.ModelSerializer):
    """Serializer for creating users - access_code is auto-generated by database, role defaults to 'member'"""
    class Meta:
        model = User
        fields = ['full_name', 'target_hours_per_week']
        read_only_fields = []


class AllowedIPSerializer(serializers.ModelSerializer):
    created_by_name = serializers.CharField(source='created_by.full_name', read_only=True)
    
    class Meta:
        model = AllowedIP
        fields = ['id', 'ip_address', 'label', 'created_by', 'created_by_name', 'created_at']
        read_only_fields = ['created_at', 'created_by_name']


class TimeLogSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True)
    duration = serializers.SerializerMethodField()
    is_active = serializers.SerializerMethodField()
    
    class Meta:
        model = TimeLog
        fields = ['id', 'user', 'clock_in', 'clock_out', 'created_at', 'duration', 'is_active']
        read_only_fields = ['created_at', 'duration', 'is_active']
    
    def get_duration(self, obj):
        """Calculate duration in seconds"""
        if obj.clock_out:
            # Ensure both datetimes are timezone-aware
            clock_in = obj.clock_in
            clock_out = obj.clock_out
            
            if timezone.is_naive(clock_in):
                clock_in = timezone.make_aware(clock_in)
            if timezone.is_naive(clock_out):
                clock_out = timezone.make_aware(clock_out)
            
            duration = clock_out - clock_in
            return round(duration.total_seconds())  # Return seconds instead of hours
        return None
    
    def get_is_active(self, obj):
        """Check if the time log is active (no clock out)"""
        return obj.clock_out is None


class LoginRequestSerializer(serializers.Serializer):
    access_code = serializers.CharField(
        max_length=6, 
        min_length=6,
        validators=[
            RegexValidator(
                regex=r'^\d{6}$',
                message='Access code must be exactly 6 digits'
            )
        ]
    )


class LoginResponseSerializer(serializers.Serializer):
    user_id = serializers.IntegerField()
    access_code = serializers.CharField()
    full_name = serializers.CharField()
    role = serializers.CharField()
    app_type = serializers.CharField(required=False)


class ClockInSerializer(serializers.Serializer):
    access_code = serializers.CharField(
        max_length=6, 
        min_length=6,
        validators=[
            RegexValidator(
                regex=r'^\d{6}$',
                message='Access code must be exactly 6 digits'
            )
        ]
    )
    ip_address = serializers.IPAddressField(required=False)


class ClockOutSerializer(serializers.Serializer):
    access_code = serializers.CharField(
        max_length=6, 
        min_length=6,
        validators=[
            RegexValidator(
                regex=r'^\d{6}$',
                message='Access code must be exactly 6 digits'
            )
        ]
    )


class TimeLogExportSerializer(serializers.ModelSerializer):
    user_access_code = serializers.CharField(source='user.access_code', read_only=True)
    user_full_name = serializers.CharField(source='user.full_name', read_only=True)
    duration_hours = serializers.SerializerMethodField()
    
    class Meta:
        model = TimeLog
        fields = ['user_access_code', 'user_full_name', 'clock_in', 'clock_out', 'duration_hours']
    
    def get_duration_hours(self, obj):
        if obj.clock_out:
            duration = obj.clock_out - obj.clock_in
            return round(duration.total_seconds() / 3600, 2)
        return None


class CommitteeMemberSerializer(serializers.ModelSerializer):
    """Serializer for committee members"""
    name = serializers.CharField(source='full_name')  # Map full_name to name for frontend
    
    class Meta:
        model = User
        fields = ['id', 'name', 'role']


class CommitteeSerializer(serializers.ModelSerializer):
    """Serializer for committees with chair and member information"""
    chair = CommitteeMemberSerializer(read_only=True)
    members = serializers.SerializerMethodField()
    member_count = serializers.SerializerMethodField()
    
    class Meta:
        model = Committee
        fields = ['id', 'name', 'chair', 'members', 'member_count', 'created_at']
        read_only_fields = ['created_at']
    
    def get_members(self, obj):
        """Get all members of the committee"""
        members = User.objects.filter(usercommittee__committee=obj).order_by('full_name')
        return CommitteeMemberSerializer(members, many=True).data
    
    def get_member_count(self, obj):
        """Get the count of members in the committee"""
        return User.objects.filter(usercommittee__committee=obj).count()


class CommitteeCreateSerializer(serializers.ModelSerializer):
    """Serializer for creating committees"""
    class Meta:
        model = Committee
        fields = ['name', 'chair']


class CommitteeUpdateSerializer(serializers.ModelSerializer):
    """Serializer for updating committees"""
    chair_id = serializers.IntegerField(write_only=True, required=False)
    chair = CommitteeMemberSerializer(read_only=True)
    
    class Meta:
        model = Committee
        fields = ['name', 'chair', 'chair_id']
    
    def update(self, instance, validated_data):
        chair_id = validated_data.pop('chair_id', None)
        if chair_id is not None:
            try:
                # Convert to int if it's a string
                chair_id = int(chair_id) if isinstance(chair_id, str) else chair_id
                chair = User.objects.get(id=chair_id)
                validated_data['chair'] = chair
            except (User.DoesNotExist, ValueError, TypeError):
                # If user doesn't exist or invalid ID, don't update the chair
                pass
        return super().update(instance, validated_data) 